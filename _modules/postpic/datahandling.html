
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>postpic.datahandling &#8212; postpic v0.4+146.g6b74ab9 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for postpic.datahandling</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># This file is part of postpic.</span>
<span class="c1">#</span>
<span class="c1"># postpic is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># postpic is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with postpic. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># Stephan Kuschel, 2014-2018</span>
<span class="c1"># Alexander Blinne, 2017</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The Core module for final data handling.</span>

<span class="sd">This module provides classes for dealing with axes, grid as well as the Field</span>
<span class="sd">class -- the final output of the postpic postprocessor.</span>

<span class="sd">Terminology</span>
<span class="sd">-----------</span>

<span class="sd">A data field with N numeric points has N &#39;grid&#39; points,</span>
<span class="sd">but N+1 &#39;grid_nodes&#39; as depicted here:</span>

<span class="sd">.. code-block:: none</span>

<span class="sd">  +---+---+---+---+---+</span>
<span class="sd">  |   |   |   |   |   |</span>
<span class="sd">  +---+---+---+---+---+</span>
<span class="sd">  |   |   |   |   |   |</span>
<span class="sd">  +---+---+---+---+---+</span>
<span class="sd">  |   |   |   |   |   |</span>
<span class="sd">  +---+---+---+---+---+</span>
<span class="sd">    o   o   o   o   o     grid      (coordinates where data is sampled at)</span>
<span class="sd">  o   o   o   o   o   o   grid_node (coordinates of grid cell boundaries)</span>
<span class="sd">  |                   |   extent</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">spnd</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">spinterp</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">import</span> <span class="nn">numexpr</span> <span class="k">as</span> <span class="nn">ne</span>

<span class="kn">from</span> <span class="nn">._compat</span> <span class="kn">import</span> <span class="n">tukey</span><span class="p">,</span> <span class="n">meshgrid</span><span class="p">,</span> <span class="n">broadcast_to</span><span class="p">,</span> <span class="n">NDArrayOperatorsMixin</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">helper</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">io</span>
<span class="kn">from</span> <span class="nn">.helper_fft</span> <span class="kn">import</span> <span class="n">fft</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">functools32</span> <span class="k">as</span> <span class="nn">functools</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">functools</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip_longest</span> <span class="k">as</span> <span class="n">zip_longest</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>


<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="c1"># skimage produces a DeprecationWarning by importing `imp`. We will silence this warning</span>
        <span class="c1"># as we have nothing to do with it</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">skimage.restoration</span> <span class="kn">import</span> <span class="n">unwrap_phase</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">unwrap_phase</span> <span class="o">=</span> <span class="kc">None</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;KeepDim&#39;</span><span class="p">,</span> <span class="s1">&#39;Field&#39;</span><span class="p">,</span> <span class="s1">&#39;Axis&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="KeepDim"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.KeepDim">[docs]</a><span class="k">class</span> <span class="nc">KeepDim</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Axis"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Axis">[docs]</a><span class="k">class</span> <span class="nc">Axis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Axis handling for a single Axis.</span>

<span class="sd">    Create an Axis object from scratch.</span>

<span class="sd">    The least required arguments are any of:</span>
<span class="sd">        * grid</span>
<span class="sd">        * grid_node</span>
<span class="sd">        * extent _and_ n</span>

<span class="sd">    The remaining fields will be deduced from the givens.</span>

<span class="sd">    More arguments may be supplied, as long as they are compatible.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;grid_node&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed array grid_node has ndim != 1.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">monotonicity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Grid_node spacing is zero on axis &quot;</span><span class="si">{}</span><span class="s1">&quot; at value </span><span class="si">{}</span><span class="s1">.&#39;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed array grid_node is not monotonous.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed array grid has ndim != 1.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">monotonicity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;Grid spacing is zero on axis &quot;</span><span class="si">{}</span><span class="s1">&quot; at value </span><span class="si">{}</span><span class="s1">.&#39;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed array grid is not monotonous.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed extent is not an iterable of length 2&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># kwargs must be exhausted now</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;got an unexpcted keyword argument &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If we are here really nothing has been passed, like with the old version</span>
                    <span class="c1"># of this class</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing required arguments for Axis construction.&quot;</span><span class="p">)</span>
                <span class="c1"># only extent and n have been passed, use that to create a linear grid_node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                              <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># grid has been passed, create grid_node from grid.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">grid_spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)),</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">gn_inner</span> <span class="o">=</span> <span class="n">grid_spline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">gn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">gn_inner</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">grid_spline</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># extent has been passed, use this for the end points of grid_node</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed invalid extent.&quot;</span><span class="p">)</span>
                    <span class="n">gn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">gn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># estimate end points of grid_node as in the old grid.setter</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">gn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">gn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">gn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span>
                        <span class="n">gn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span> <span class="o">=</span> <span class="n">gn</span>

        <span class="c1"># now we are garantueed to have a grid_node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create grid from grid_node like in the old grid.getter</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">node_spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
                                                                           <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">node_spline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">del</span> <span class="n">node_spline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check if grid and grid_node are compatible</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points of passed grid are not within corresponding &quot;</span>
                                 <span class="s2">&quot;grid_nodes.&quot;</span><span class="p">)</span>

        <span class="c1"># set extent if not given or check if compatible with grid_node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed invalid extent.&quot;</span><span class="p">)</span>

        <span class="c1"># make sure grid and grid_node is immutable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># make sure the extent is also immutable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">)</span>

        <span class="c1"># set n if not given or check if compatible with grid</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed invalid value of n.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inv_map</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Excludes self._inv_map from the pickled state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>  <span class="c1"># shallow copy</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_inv_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        equality test for axis</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">testattribs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_node&#39;</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ta</span> <span class="ow">in</span> <span class="n">testattribs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ta</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ta</span><span class="p">))):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Axis.islinear"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Axis.islinear">[docs]</a>    <span class="k">def</span> <span class="nf">islinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the axis has a linear grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">islinear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isreversed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">islinear</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Grid must be linear to calculate gridspacing&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">physical_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_value_to_index_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_and_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">grid_and_nodes</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_node</span>
            <span class="n">grid_and_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>

            <span class="n">indices_grid_and_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_and_nodes</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_inv_map</span> <span class="o">=</span> <span class="n">spinterp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">grid_and_nodes</span><span class="p">,</span> <span class="n">indices_grid_and_nodes</span><span class="p">)</span>

        <span class="c1"># clip the input values to the axes grid range</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_map</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_value_to_index_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
        <span class="n">lg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">lg</span> <span class="o">-</span> <span class="mf">0.5</span>

    <span class="k">def</span> <span class="nf">_find_nearest_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the index i of the value array[i] which is closest to value.</span>
<span class="sd">        Assumes that the array is sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isreversed</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="c1"># assert sortgrid is actually sorted</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sortgrid</span><span class="p">)</span> <span class="o">==</span> <span class="n">sortgrid</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="p">{</span><span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;right&#39;</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">isreversed</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">sortgrid</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isreversed</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">idx</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">idx</span><span class="p">])):</span>
            <span class="k">return</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span>

<div class="viewcode-block" id="Axis.value_to_index"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Axis.value_to_index">[docs]</a>    <span class="k">def</span> <span class="nf">value_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This funtion is used to map values to indices in an interpolating manner, this is</span>
<span class="sd">        mainly used by the `map_coordinates` method of the `Field` class.</span>

<span class="sd">        In contrast to the `_find_nearest_index` method, this method does not return an integer</span>
<span class="sd">        but a fractional index that refers to a position between actual pixels.</span>

<span class="sd">        In general the equality</span>

<span class="sd">        `ax._find_nearest_index(x) == np.round(ax.value_to_index(x))`</span>

<span class="sd">        should hold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">islinear</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_to_index_linear</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_to_index_nonlinear</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axis.half_resolution"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Axis.half_resolution">[docs]</a>    <span class="k">def</span> <span class="nf">half_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        removes every second grid_node.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">grid_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid_node</span><span class="o">=</span><span class="n">grid_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">_inside_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns true if val is inside the extent.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">se</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">se</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_extent_to_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if the extent reverses the axis, the step argument of the returned slice is</span>
<span class="sd">        automatically set to -1, effectively auto-reversing the axis.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inside_domain</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_domain</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;The extent limits </span><span class="si">{}</span><span class="s1"> must at least overlap with the domain extent </span><span class="si">{}</span><span class="s1">.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">))</span>

        <span class="n">sortgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isreversed</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="c1"># assert sortgrid is actually sorted</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sortgrid</span><span class="p">)</span> <span class="o">==</span> <span class="n">sortgrid</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="p">{</span><span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;right&#39;</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">isreversed</span><span class="p">]</span>
        <span class="n">slicelims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">sortgrid</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isreversed</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">slicelims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">slicelims</span>
        <span class="c1"># auto-reverse is necessary</span>
        <span class="n">slicedir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isreversed</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">slicedir</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_normalize_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies some checks and transformations to the object passed</span>
<span class="sd">        to __getitem__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">KeepDim</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">value</span>
            <span class="n">keepdim</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keepdim</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">helper</span><span class="o">.</span><span class="n">is_non_integer_real_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Non-Integer slices must have step == None&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent_to_slice</span><span class="p">((</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">index</span>

        <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">is_non_integer_real_number</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="c1"># Indexing to a single position outside the extent</span>
            <span class="c1"># will yield IndexError. Identical behaviour as numpy.ndarray</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_domain</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Physical index position </span><span class="si">{}</span><span class="s1"> is outside of the &#39;</span> \
                      <span class="s1">&#39;extent </span><span class="si">{}</span><span class="s1"> of axis </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_nearest_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keepdim</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">index</span>

<div class="viewcode-block" id="Axis.reversed"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Axis.reversed">[docs]</a>    <span class="k">def</span> <span class="nf">reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns an reversed Axis object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">grid_node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ax</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an Axis which consists of a sub-part of this object defined by</span>
<span class="sd">        a slice containing floats or integers or a float or an integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_slice</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">step</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;slice.step must be 1, -1 or None (but is </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">step</span><span class="p">))</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">sl</span><span class="o">.</span><span class="n">stop</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">sl</span><span class="o">.</span><span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">sln</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">sl</span><span class="o">.</span><span class="n">start</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="n">grid_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[</span><span class="n">sln</span><span class="p">]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid_node</span><span class="o">=</span><span class="n">grid_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&lt;Axis &quot;</span><span class="si">{}</span><span class="s1">&quot; (</span><span class="si">{}</span><span class="s1"> grid points from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">)&gt;&#39;</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span></div>


<span class="k">def</span> <span class="nf">_reducing_numpy_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function produces methods that are suitable for the `Field` class</span>
<span class="sd">    that reproduce the behaviour of the corresponding numpy `method`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># we need to interpret the axis object and create an iterable axisiter</span>
        <span class="c1"># in order to iterate over the affected axes</span>
        <span class="n">axisiter</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">axisiter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axisiter</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axisiter</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">axisiter</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>

        <span class="c1"># no `out` argument supplied, we need to figure out the axes of the result</span>
        <span class="c1"># and deal with other state of the Field</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">tao</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">)</span>
            <span class="n">ats</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axisiter</span><span class="p">:</span>
                    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">axisiter</span><span class="p">)):</span>
                    <span class="k">del</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">tao</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">ats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># If the supplied `out` argument is a Field, we need to extract the plain array</span>
        <span class="c1"># from it in order to pass to the real method</span>
        <span class="n">real_out</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">real_out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">real_out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">matrix</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">else</span> <span class="n">o</span><span class="p">)</span>

        <span class="c1"># call the underlying method and pass on `keepdims` if it is different from</span>
        <span class="c1"># None. Passing on `None` does not work because the default value is a special</span>
        <span class="c1"># object, see &lt;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/</span>
        <span class="c1"># numpy.all.html#numpy.all&gt;</span>
        <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
        <span class="n">o</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">real_out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># if an `out` argument was supplied, just return it</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="c1"># create and return a Field object from the result.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                                   <span class="n">axes_transform_state</span><span class="o">=</span><span class="n">ats</span><span class="p">,</span> <span class="n">transformed_axes_origins</span><span class="o">=</span><span class="n">tao</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">o</span>
                        <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                             <span class="n">axes_transform_state</span><span class="o">=</span><span class="n">ats</span><span class="p">,</span> <span class="n">transformed_axes_origins</span><span class="o">=</span><span class="n">tao</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="n">new_method</span>


<span class="c1"># The NDArrayOperatorsMixin implements all arithmetic special functions through numpy</span>
<span class="c1"># ufuncs</span>
<div class="viewcode-block" id="Field"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field">[docs]</a><span class="k">class</span> <span class="nc">Field</span><span class="p">(</span><span class="n">NDArrayOperatorsMixin</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The Field Object carries data in form of an `numpy.ndarray` together with as many Axis</span>
<span class="sd">    objects as the data&#39;s dimensions. Additionaly the Field object</span>
<span class="sd">    provides any information that is necessary to plot _and_ annotate</span>
<span class="sd">    the plot.</span>

<span class="sd">    Create a Field object from scratch. The only required argument is `matrix` which</span>
<span class="sd">    contains the actual data.</span>

<span class="sd">    A `name` and a `unit` may be supplied.</span>

<span class="sd">    The axis may be specified in different ways:</span>

<span class="sd">    * by passing a list of Axis object as `axes`</span>
<span class="sd">    * by passing arrays with the grid_nodes as `xedges`, `yedges` and `zedges`.</span>
<span class="sd">      This is intended to work with `np.histogram`.</span>
<span class="sd">    * by not passing anything, which will create default axes from 0 to 1.</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Field.loadfrom"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.loadfrom">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@helper</span><span class="o">.</span><span class="n">append_doc_of</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">load_field</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">loadfrom</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">load_field</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="Field.importfrom"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.importfrom">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@helper</span><span class="o">.</span><span class="n">append_doc_of</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">import_field</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">importfrom</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">import_field</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;xedges&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># Some axes have been passed, let length-1-dimensions alone</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>  <span class="c1"># dont sqeeze. trust numpys histogram functions.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No axes have been passed. Squeeze away length-1-dimensions.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infostring</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># autogenerated if None</span>

        <span class="k">if</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of supplied axis to small&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setaxisobj</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;xedges&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addaxisnodes</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xedges&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addaxis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;yedges&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addaxisnodes</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;yedges&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addaxis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;zedges&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addaxisnodes</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;zedges&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addaxis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>

        <span class="c1"># Additions due to FFT capabilities</span>

        <span class="c1"># self.axes_transform_state is False for axes which live in spatial domain</span>
        <span class="c1"># and it is True for axes which live in frequency domain</span>
        <span class="c1"># This assumes that fields are initially created in spatial domain.</span>
        <span class="k">if</span> <span class="s1">&#39;axes_transform_state&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axes_transform_state&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># self.transformed_axes_origins stores the starting values of the grid</span>
        <span class="c1"># from before the last transform was executed, this is used to</span>
        <span class="c1"># recreate the correct axis interval upon inverse transform</span>
        <span class="k">if</span> <span class="s1">&#39;transformed_axes_origins&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed_axes_origins&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns a shallow copy of the object.</span>
<span class="sd">        This method is called by `copy.copy(obj)`.</span>
<span class="sd">        Just copy enough to create copies for operator overloading.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns a deep copy of the object.</span>
<span class="sd">        This method is called by `copy.deepcopy(obj)`.</span>

<span class="sd">        Although Field objects are mostly immutable, they have a __setitem__, which is useful</span>
<span class="sd">        in some cases. Sometimes, one needs an easy way to copy a Field before using __setitem__.</span>
<span class="sd">        This function copies the underlying data to make sure that no modifications applied to</span>
<span class="sd">        the copy affect the source.</span>

<span class="sd">        As the contents of `axes` should be strictly immutable, they don&#39;t need to be copied.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Field.copy"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a copy of the Field.</span>

<span class="sd">        deep: return a deep copy, optional</span>
<span class="sd">        order: {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">            Controls the memory layout of the copy. Only applies to deep copies. See</span>
<span class="sd">            `numpy.ndarray.copy` for more details.</span>
<span class="sd">            Default is &#39;C&#39;-Order.</span>

<span class="sd">        Similar to `numpy.ndarray.copy`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>  <span class="c1"># shallow copy</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;infos&#39;</span><span class="p">,</span> <span class="s1">&#39;axes_transform_state&#39;</span><span class="p">,</span> <span class="s1">&#39;transformed_axes_origins&#39;</span><span class="p">,</span> <span class="s1">&#39;axes&#39;</span><span class="p">]:</span>
            <span class="n">ret</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1"># Stuff related with compatibility to Numpy&#39;s ufuncs starts here.</span>
    <span class="k">def</span> <span class="nf">_get_axes_ats_tao_binary_ufunc_broadcasting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute the axes, axes_transform_state and transformed_axes_origins for the result</span>
<span class="sd">        of a binary ufunc __call__ operation between self and other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="c1"># if other is just a number, all properties should be inherited from self</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span>

        <span class="c1"># some short hands...</span>
        <span class="n">axes1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">ats1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span>
        <span class="n">tao1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span>

        <span class="c1"># create short hands for the properties of other</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
            <span class="c1"># if other is a plain array, fill everything with None</span>
            <span class="n">axes2</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">ats2</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">tao2</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">axes</span>
            <span class="n">ats2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">axes_transform_state</span>
            <span class="n">tao2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">transformed_axes_origins</span>

        <span class="c1"># print(&quot;_get_axes_ats_tao_binary_ufunc_broadcasting self:&quot;, axes1, ats1, tao1)</span>
        <span class="c1"># print(&quot;_get_axes_ats_tao_binary_ufunc_broadcasting other:&quot;, axes2, ats2, tao2)</span>

        <span class="c1"># resulting array has total_dim dimensions</span>
        <span class="n">total_dim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axes1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes2</span><span class="p">))</span>

        <span class="c1"># enumerate axes objects and convert to a list, to support reverse iteration</span>
        <span class="n">axes1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">axes1</span><span class="p">))</span>
        <span class="n">axes2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">axes2</span><span class="p">))</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">axes_transform_state</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">transformed_axes_origins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># collect result properties starting from the last axis, as broadcasting logic</span>
        <span class="c1"># of numpy also starts with last axis</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">ax1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">axes1</span><span class="p">),</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">axes2</span><span class="p">),</span>
                                                <span class="n">fillvalue</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ax1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># ax1 is None, just use ax2</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span>
                <span class="n">axes_transform_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ats2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
                <span class="n">transformed_axes_origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tao2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">ax2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># ax2 is None, just use ax1</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
                <span class="n">axes_transform_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ats1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
                <span class="n">transformed_axes_origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tao1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2</span><span class="p">):</span>
                <span class="c1"># both axes have same length, both should be valid.</span>
                <span class="c1"># TODO: Check if axes are really equal</span>
                <span class="c1"># print(len(ax1), len(ax2), ats1[i1], tao1[i1], ats2[i2], tao2[i2])</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>

                <span class="c1"># we are not sure from which axis we should take ats and tao. guess...</span>
                <span class="k">if</span> <span class="n">tao2</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">axes_transform_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ats1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
                    <span class="n">transformed_axes_origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tao1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axes_transform_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ats2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
                    <span class="n">transformed_axes_origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tao2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># ax1 has length 1, use ax2</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span>
                <span class="n">axes_transform_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ats2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
                <span class="n">transformed_axes_origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tao2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># ax2 has length 1, use ax1</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
                <span class="n">axes_transform_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ats1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
                <span class="n">transformed_axes_origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tao1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes for broadcasting&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">axes</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">axes_transform_state</span><span class="p">)),</span> \
            <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">transformed_axes_origins</span><span class="p">))</span>

    <span class="c1"># make sure that np.array() * Field() returns a Field and not a plain array</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        will be called by numpy function in case an numpy array is needed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># What kind of other objects do we support? so far any kind of numpy array or scalar number</span>
    <span class="n">_HANDLED_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>

    <span class="c1"># handle ufuncs, new interface.</span>
    <span class="c1"># see https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/[...]</span>
    <span class="c1"># [...]/numpy.lib.mixins.NDArrayOperatorsMixin.html#numpy.lib.mixins.NDArrayOperatorsMixin</span>
    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Have implemented neither &#39;reduceat&#39; because it is crazy nor</span>
        <span class="c1"># &#39;inner&#39; because it is not documented</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;__call__&#39;</span><span class="p">,</span> <span class="s1">&#39;reduce&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="s1">&#39;at&#39;</span><span class="p">,</span> <span class="s1">&#39;accumulate&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="o">+</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># Only support operations with instances of _HANDLED_TYPES.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HANDLED_TYPES</span> <span class="o">+</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),)):</span>
                <span class="c1"># Any unsupported operation should return NotImplemented such that</span>
                <span class="c1"># numpy can continue to look for other methods that might support it</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># TODO: add check of Axes extent and unit here</span>

        <span class="c1"># If out-argument set, an output Field was already created. Do not wworry</span>
        <span class="c1"># about axes in that case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># unary operation, leave everything as it is</span>
                    <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
                    <span class="n">ats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span>
                    <span class="n">tao</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># binary operation, use Field._get_axes_ats_tao_binary_ufunc_broadcasting</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">inputs</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                        <span class="n">axes</span><span class="p">,</span> <span class="n">ats</span><span class="p">,</span> <span class="n">tao</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_get_axes_ats_tao_binary_ufunc_broadcasting</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                        <span class="n">axes</span><span class="p">,</span> <span class="n">ats</span><span class="p">,</span> <span class="n">tao</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_get_axes_ats_tao_binary_ufunc_broadcasting</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">NotImplemented</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;accumulate&#39;</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
                <span class="n">ats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span>
                <span class="n">tao</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;reduce&#39;</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
                <span class="n">ats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">[:]</span>
                <span class="n">tao</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[:]</span>
                <span class="n">reduceaxis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reduceaxis</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                    <span class="n">reduceaxis</span> <span class="o">=</span> <span class="p">(</span><span class="n">reduceaxis</span><span class="p">,)</span>
                <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">reduceaxis</span><span class="p">))):</span>
                    <span class="k">del</span> <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">ats</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">tao</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ats</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">tao</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                        <span class="n">axes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
                        <span class="n">ats</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">)</span>
                        <span class="n">tao</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">()</span>
                            <span class="n">a</span><span class="o">.</span><span class="n">setextent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                            <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                            <span class="n">ats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">tao</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;at&#39;</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Defer to the implementation of the ufunc on unwrapped values.</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">matrix</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">matrix</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">matrix</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If out-argument set, return it. Unpack a one-tuple (important for binary inplace ops)</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="c1"># Otherwise, the ufunc has returned one or more simple array(s). Wrap this/these</span>
        <span class="c1"># with the `axes`</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="c1"># multiple return values</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                                    <span class="n">axes_transform_state</span><span class="o">=</span><span class="n">ats</span><span class="p">,</span> <span class="n">transformed_axes_origins</span><span class="o">=</span><span class="n">tao</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;at&#39;</span><span class="p">:</span>
            <span class="c1"># no return value</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># one return value</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                             <span class="n">axes_transform_state</span><span class="o">=</span><span class="n">ats</span><span class="p">,</span> <span class="n">transformed_axes_origins</span><span class="o">=</span><span class="n">tao</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="c1"># wrap ufunc results from numpy &lt; 1.13 as Fields.</span>
    <span class="c1"># This is also used for __add__ and so on as they are implemented through ufuncs via</span>
    <span class="c1"># NDArrayOperatorsMixin.</span>
    <span class="c1"># This is not intended to be perfect because it is barely possible to get it right</span>
    <span class="c1"># with the old interface</span>
    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># this is a Field already, leave it as is</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">array</span>

        <span class="c1"># fallback defaults</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">ats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span>
        <span class="n">tao</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span>

        <span class="c1"># if we have `context`, there might be a chance...</span>
        <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">context</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># binary operation, use Field._get_axes_ats_tao_binary_ufunc_broadcasting</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">inputs</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                    <span class="n">axes</span><span class="p">,</span> <span class="n">ats</span><span class="p">,</span> <span class="n">tao</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_get_axes_ats_tao_binary_ufunc_broadcasting</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                    <span class="n">axes</span><span class="p">,</span> <span class="n">ats</span><span class="p">,</span> <span class="n">tao</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_get_axes_ats_tao_binary_ufunc_broadcasting</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="c1"># we might have gotten `axes` right...</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                              <span class="n">axes_transform_state</span><span class="o">=</span><span class="n">ats</span><span class="p">,</span> <span class="n">transformed_axes_origins</span><span class="o">=</span><span class="n">tao</span><span class="p">)</span>

        <span class="c1"># Have no Idea what the axes should be. Return plain `ndarray`.</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="k">def</span> <span class="nf">_addaxisobj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisobj</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        uses the given axisobj as the axis obj in the given dimension.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># check if number of grid points match</span>
        <span class="n">matrixpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">matrixpts</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisobj</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Number of Grid points in next missing Data &#39;</span>
                <span class="s1">&#39;Dimension (</span><span class="si">{:d}</span><span class="s1">) has to match number of grid points of &#39;</span>
                <span class="s1">&#39;new axis (</span><span class="si">{:d}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matrixpts</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisobj</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axisobj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_addaxisnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">grid_node</span><span class="o">=</span><span class="n">grid_node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_addaxisobj</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_addaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        adds a new axis that is supported by the matrix.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">matrixpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">matrixpts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_addaxisobj</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

<div class="viewcode-block" id="Field.setaxisobj"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.setaxisobj">[docs]</a>    <span class="k">def</span> <span class="nf">setaxisobj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">axisobj</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        replaces the current axisobject for axis axis by the</span>
<span class="sd">        new axisobj axisobj.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">axid</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">axesidentify</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">axid</span> <span class="o">=</span> <span class="n">axid</span> <span class="o">%</span> <span class="mi">90</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisobj</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axid</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Axis object has </span><span class="si">{:3n}</span><span class="s1"> grid points, whereas &#39;</span>
                             <span class="s1">&#39;the data matrix has </span><span class="si">{:3n}</span><span class="s1"> on axis </span><span class="si">{:1n}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axisobj</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axid</span><span class="p">],</span> <span class="n">axid</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axid</span><span class="p">]</span> <span class="o">=</span> <span class="n">axisobj</span></div>

<div class="viewcode-block" id="Field.islinear"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.islinear">[docs]</a>    <span class="k">def</span> <span class="nf">islinear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">islinear</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@label</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span>

    <span class="nd">@matrix</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of old and new matrix must be identical&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">other</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">grid_node</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">])</span>

<div class="viewcode-block" id="Field.meshgrid"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.meshgrid">[docs]</a>    <span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns only present dimensions.</span>
<span class="sd">        [] and [[]] are interpreted as -1</span>
<span class="sd">        np.array(2) is interpreted as 0</span>
<span class="sd">        np.array([1,2,3]) is interpreted as 1</span>
<span class="sd">        and so on...</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># works for everything with data.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># handels everything without data</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns the extents in a linearized form,</span>
<span class="sd">        as required by &quot;matplotlib.pyplot.imshow&quot;.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">extent</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">])</span>

    <span class="nd">@extent</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newextent</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        sets the new extent to the specific values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">newextent</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;size of newextent doesnt match self.dimensions * 2&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">islinear</span><span class="p">():</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;resetting the extent for an axis with non-linear grid is not yet supported.&#39;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">newax</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                         <span class="n">extent</span><span class="o">=</span><span class="n">newextent</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setaxisobj</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newax</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        returns the grid spacings for all axis.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ax</span><span class="o">.</span><span class="n">spacing</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Field.phase"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.phase">[docs]</a>    <span class="k">def</span> <span class="nf">phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">do_unwrap_phase</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the (unwrapped) phase of the complex Field.</span>

<span class="sd">        do_unwrap_phase: True, if skimage.restoration.unwrap_phase should be applied to data</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_unwrap_phase</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">unwrap_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$\varphi$(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;rad&#39;</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.conj"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Field.replace_data"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.replace_data">[docs]</a>    <span class="k">def</span> <span class="nf">replace_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.evaluate"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">local_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">global_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the expression `ex` using `NumExpr` and returns a field containing the result.</span>
<span class="sd">        This copies all metadata from `self` and just replaces the matrix.</span>

<span class="sd">        This function is basically syntactic sugar simplifying</span>

<span class="sd">        ```field.replace_data(ne.evaluate(expr))```</span>

<span class="sd">        to</span>

<span class="sd">        ```field.evaluate(expr)```</span>

<span class="sd">        This method replicates some logic from NumExpr.necompiler.getArguments(), seems</span>
<span class="sd">        there is no way around it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call_frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">clear_local_dict</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">local_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">local_dict</span> <span class="o">=</span> <span class="n">call_frame</span><span class="o">.</span><span class="n">f_locals</span>
            <span class="n">clear_local_dict</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">frame_globals</span> <span class="o">=</span> <span class="n">call_frame</span><span class="o">.</span><span class="n">f_globals</span>
            <span class="k">if</span> <span class="n">global_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">global_dict</span> <span class="o">=</span> <span class="n">frame_globals</span>

            <span class="c1"># If `call_frame` is the top frame of the interpreter we can&#39;t clear its</span>
            <span class="c1"># `local_dict`, because it is actually the `global_dict`.</span>
            <span class="n">clear_local_dict</span> <span class="o">=</span> <span class="n">clear_local_dict</span> <span class="ow">and</span> <span class="n">frame_globals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">local_dict</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">local_dict</span><span class="o">=</span><span class="n">local_dict</span><span class="p">,</span>
                                                <span class="n">global_dict</span><span class="o">=</span><span class="n">global_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clear_local_dict</span><span class="p">:</span>
                <span class="n">local_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.pad"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.pad">[docs]</a>    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Pads the data using `np.pad` and takes care of the axes.</span>
<span class="sd">        See documentation of `numpy.pad`.</span>

<span class="sd">        In contrast to `np.pad`, `pad_width` may be given as integers, which will be interpreted</span>
<span class="sd">        as pixels, or as floats, which will be interpreted as distance along the appropriate axis.</span>

<span class="sd">        All other parameters are passed to `np.pad` unchanged.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">islinear</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Padding the axes is only meaningful with linear axes.&#39;</span>
                             <span class="s1">&#39;Please apply np.pad to the matrix by yourself and update the axes&#39;</span>
                             <span class="s1">&#39;as you like.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">pad_width</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pad_width</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please check your pad_width argument. If it is an Iterable, its&#39;</span>
                             <span class="s1">&#39;length must equal the number of dimensions of this Field.&#39;</span><span class="p">)</span>

        <span class="n">pad_width_numpy</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">padded_axes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis_pad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pad_width</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis_pad</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">axis_pad</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis_pad</span><span class="p">,</span> <span class="n">axis_pad</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_pad</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_pad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">axis_pad</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axis_pad</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>

            <span class="n">axis</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">dx</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">spacing</span>
            <span class="n">axis_pad</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">is_non_integer_real_number</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">p</span>
                        <span class="k">for</span> <span class="n">p</span>
                        <span class="ow">in</span> <span class="n">axis_pad</span><span class="p">]</span>
            <span class="n">pad_width_numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis_pad</span><span class="p">)</span>

            <span class="n">totalpad_axis</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">axis_pad</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">totalpad_axis</span><span class="p">:</span>
                <span class="n">padded_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">extent</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">extent</span>
                <span class="n">newextent</span> <span class="o">=</span> <span class="p">[</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">axis_pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">axis_pad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dx</span><span class="p">]</span>
                <span class="n">gridpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">grid_node</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">axis_pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">axis_pad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">newextent</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">gridpoints</span><span class="p">)</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pad_width_numpy</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># This info is invalidated for all axes which have actually been padded</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">padded_axes</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.half_resolution"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.half_resolution">[docs]</a>    <span class="k">def</span> <span class="nf">half_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Halfs the resolution along the given axis by removing</span>
<span class="sd">        every second `grid_node` and averaging every second data point into one.</span>

<span class="sd">        If there is an odd number of grid points, the last point will</span>
<span class="sd">        be ignored (that means, the extent will change by the size of</span>
<span class="sd">        the last grid cell).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Field:</span>
<span class="sd">            the modified `Field`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">axesidentify</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="c1"># ignore last grid point if self.matrix.shape[axis] is odd</span>
        <span class="n">lastpt</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="c1"># Averaging over neighboring points</span>
        <span class="n">s1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lastpt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">s2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">lastpt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s2</span><span class="p">)])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">setaxisobj</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">half_resolution</span><span class="p">())</span>

        <span class="c1"># This info is invalidated</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.map_axis_grid"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.map_axis_grid">[docs]</a>    <span class="k">def</span> <span class="nf">map_axis_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">preserve_integral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jacobian_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the Field to new coordinates along one axis.</span>

<span class="sd">        This function transforms the coordinates of one axis according to the function</span>
<span class="sd">        `transform` and applies the jacobian to the data.</span>

<span class="sd">        Please note that no interpolation is applied to the data, instead a non-linear</span>
<span class="sd">        axis grid is produced. If you want to interpolate the data to a new (linear) grid,</span>
<span class="sd">        use the method :meth:`map_coordinates` instead.</span>

<span class="sd">        In contrast to :meth:`map_coordinates`,</span>
<span class="sd">        the function transform is not used to pull the new data</span>
<span class="sd">        points from the old grid, but is directly applied to the axis. This reverses the</span>
<span class="sd">        direction of the transform. Therfore, in order to preserve the integral,</span>
<span class="sd">        it is necessary to divide by the Jacobian.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis: int</span>
<span class="sd">            the index or name of the axis you want to apply transform to.</span>

<span class="sd">        transform: callable</span>
<span class="sd">            the transformation function which takes the old coordinates as an input</span>
<span class="sd">            and returns the new grid</span>

<span class="sd">        preserve_integral: bool</span>
<span class="sd">            Divide by the jacobian of transform, in order to preserve the</span>
<span class="sd">            integral.</span>

<span class="sd">        jacobian_func: callable</span>
<span class="sd">            If given, this is expected to return the derivative of transform.</span>
<span class="sd">            If not given, the derivative is numerically approximated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">axesidentify</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">preserve_integral</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">jacobian_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jacobian_func</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">approx_1d_jacobian_det</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

            <span class="n">jac_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="n">jac_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

            <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">jacobian_func</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">),</span>
                                                 <span class="n">jac_shape</span><span class="p">)</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">grid_node</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid_node</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                              <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid_node</span><span class="o">=</span><span class="n">grid_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">_map_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newaxes</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">complex_mode</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">,</span>
                         <span class="n">preserve_integral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jacobian_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">jacobian_determinant_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        complex_mode:</span>
<span class="sd">            The complex_mode specifies how to proceed with complex data.</span>

<span class="sd">            * complex_mode = &#39;cartesian&#39; - interpolate real/imag part (fastest)</span>
<span class="sd">            * complex_mode = &#39;polar&#39; - interpolate abs/phase \</span>
<span class="sd">            If skimage.restoration is available, the phase will be unwrapped first (default)</span>
<span class="sd">            * complex_mode = &#39;polar-no-unwrap&#39; - interpolate abs/phase \</span>
<span class="sd">            Skip unwrapping the phase, even if skimage.restoration is available</span>

<span class="sd">        preserve_integral: bool</span>
<span class="sd">            If True (the default), the data will be multiplied with the</span>
<span class="sd">            Jacobian determinant of the coordinate transformation such that the integral</span>
<span class="sd">            over the data will be preserved.</span>

<span class="sd">            In general, you will want to do this, because the physical unit of the new Field will</span>
<span class="sd">            correspond to the new axis of the Fields. Please note that Postpic, currently, does not</span>
<span class="sd">            automatically change the unit members of the Axis and Field objects, this you will have</span>
<span class="sd">            to do manually.</span>

<span class="sd">            There are, however, exceptions to this rule. Most prominently, if you are converting to</span>
<span class="sd">            polar coordinates,</span>
<span class="sd">            it depends on what you are going to do with the transformed Field.</span>
<span class="sd">            If you intend to do a Cartesian r-theta plot or are interested in a lineout</span>
<span class="sd">            for a single value of theta, you do want to apply the Jacobian determinant.</span>
<span class="sd">            If you had a density in</span>
<span class="sd">            e.g. J/m^2 than, in polar coordinates, you want to have a density in J/m/rad.</span>
<span class="sd">            If you intend, on the other hand, to do a polar plot, you do not want to apply the</span>
<span class="sd">            Jacobian. In a polar plot, the data points are plotted with variable density which</span>
<span class="sd">            visually takes care of the Jacobian automatically. A polar plot of the polar data</span>
<span class="sd">            should look like a Cartesian plot of the original data with just a peculiar coordinate</span>
<span class="sd">            grid drawn over it.</span>

<span class="sd">        jacobian_determinant_func: callable</span>
<span class="sd">            A callable that returns the jacobian determinant of</span>
<span class="sd">            the transform. If given, this takes precedence over the following option.</span>

<span class="sd">        jacobian_func: callable</span>
<span class="sd">            a callable that returns the jacobian of the transform. If this is</span>
<span class="sd">            not given, the jacobian is numerically approximated.</span>
<span class="sd">            In a 1D to 1D transform this callable should return just the derivative of the</span>
<span class="sd">            transform wrapped in a 1-element iterable.</span>

<span class="sd">        **kwargs:</span>
<span class="sd">            Keyword arguments captured by `helper.map_coordinates_parallel`:</span>
<span class="sd">            `chunklen` and `threads`.</span>

<span class="sd">            chunklen: Size of the chunks in pixels per axis. Default: None</span>
<span class="sd">                Special values:</span>
<span class="sd">                    None: Automatic (Chooses a default based on number of dimensions)</span>
<span class="sd">                    0: Do not split data into chunks. (implicitly sets threads==1)</span>

<span class="sd">            threads: Number of threads. Default: None</span>
<span class="sd">                None: Automatic (One thread per available processing unit)</span>

<span class="sd">            Additional keyword arguments are passed to `scipy.ndimage.map_coordinates`,</span>
<span class="sd">            see the documentation of that function.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Instantiate an identity if no transformation function was given</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span>

            <span class="k">def</span> <span class="nf">jacobian_determinant_func</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="n">preserve_integral</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newaxes</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Preserving the integral through preserve_integral=True is only&#39;</span>
                                 <span class="s1">&#39;possible for transforms that have the same number of input and&#39;</span>
                                 <span class="s1">&#39;output dimensions.&#39;</span>
                                 <span class="s1">&#39;Please pass preserve_integral=False explicitly to allow such&#39;</span>
                                 <span class="s1">&#39;transforms.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">jacobian_determinant_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">jacobian_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">jacobian_func</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">approx_jacobian</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
                <span class="n">jacobian_determinant_func</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">jac_det</span><span class="p">(</span><span class="n">jacobian_func</span><span class="p">)</span>

        <span class="n">do_unwrap_phase</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">complex_mode</span> <span class="o">==</span> <span class="s1">&#39;polar-no-unwrap&#39;</span><span class="p">:</span>
            <span class="n">complex_mode</span> <span class="o">=</span> <span class="s1">&#39;polar&#39;</span>
            <span class="n">do_unwrap_phase</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Start a new Field object by inserting the new axes</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">newaxes</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">newaxes</span><span class="p">]</span>

        <span class="c1"># Calculate the output grid</span>
        <span class="n">out_coords</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">()</span>

        <span class="c1"># Calculate the source points for every point of the new mesh</span>
        <span class="n">coordinates_ax</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="o">*</span><span class="n">out_coords</span><span class="p">)</span>

        <span class="c1"># Rescale the source coordinates to pixel coordinates</span>
        <span class="n">coordinates_px</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">value_to_index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">coordinates_ax</span><span class="p">)]</span>

        <span class="c1"># Broadcast all coordinate arrays to the new shape</span>
        <span class="n">coordinates_px</span> <span class="o">=</span> <span class="p">[</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coordinates_px</span><span class="p">]</span>

        <span class="c1"># Map the matrix using helper.map_coordinates_parallel</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">map_coordinates_parallel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">coordinates_px</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">complex_mode</span> <span class="o">==</span> <span class="s1">&#39;cartesian&#39;</span><span class="p">:</span>
                <span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">imag</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="o">*</span><span class="n">coordinates_px</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">map_coordinates_parallel</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">coordinates_px</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">map_coordinates_parallel</span><span class="p">(</span><span class="n">imag</span><span class="p">,</span> <span class="n">coordinates_px</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">complex_mode</span> <span class="o">==</span> <span class="s1">&#39;polar&#39;</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;arctan2(self.imag, self.real)&#39;</span><span class="p">)</span>
                <span class="n">absval</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;abs(self).real&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">do_unwrap_phase</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">unwrap_phase</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="n">unwrap_phase</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Function unwrap_phase from skimage.restoration not &quot;</span>
                                      <span class="s2">&quot;available! Install scikit-image or use complex_mode = &quot;</span>
                                      <span class="s2">&quot;&#39;polar-no-unwrap&#39; to get rid of this warning.&quot;</span><span class="p">)</span>

                <span class="n">absval</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">map_coordinates_parallel</span><span class="p">(</span><span class="n">absval</span><span class="p">,</span> <span class="n">coordinates_px</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">map_coordinates_parallel</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">coordinates_px</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;absval * exp(1j * angle)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value of complex_mode.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">preserve_integral</span><span class="p">:</span>
            <span class="n">jac_det</span> <span class="o">=</span> <span class="n">jacobian_determinant_func</span><span class="p">(</span><span class="o">*</span><span class="n">out_coords</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;ret * jac_det&#39;</span><span class="p">)</span>

        <span class="c1"># This info is invalidated</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">ret</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="n">transform_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">transform_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform_state</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">axes_transform_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform_state</span><span class="p">]</span><span class="o">*</span><span class="n">ret</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="Field.map_coordinates"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.map_coordinates">[docs]</a>    <span class="nd">@helper</span><span class="o">.</span><span class="n">append_doc_of</span><span class="p">(</span><span class="n">_map_coordinates</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">map_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newaxes</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">complex_mode</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">,</span>
                        <span class="n">preserve_integral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jacobian_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">jacobian_determinant_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the Field to new coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newaxes: list</span>
<span class="sd">            The new axes of the new coordinates.</span>

<span class="sd">        transform: callable</span>
<span class="sd">            a callable that takes the new coordinates as input and returns</span>
<span class="sd">            the old coordinates from where to sample the Field.</span>
<span class="sd">            It is basically the inverse of the transformation that you want to perform.</span>
<span class="sd">            If transform is not given, the identity will be used. This is suitable for</span>
<span class="sd">            simple interpolation to a new extent/shape.</span>
<span class="sd">            Example for cartesian -&gt; polar:</span>

<span class="sd">            &gt;&gt;&gt; def T(r, theta):</span>
<span class="sd">            &gt;&gt;&gt;    x = r * np.cos(theta)</span>
<span class="sd">            &gt;&gt;&gt;    y = r * np.sin(theta)</span>
<span class="sd">            &gt;&gt;&gt;    return x, y</span>

<span class="sd">            Note that this function actually computes the cartesian coordinates from the polar</span>
<span class="sd">            coordinates, but stands for transforming a field in cartesian coordinates into a</span>
<span class="sd">            field in polar coordinates.</span>

<span class="sd">            However, in order to preserve the definite integral of</span>
<span class="sd">            the field, it is necessary to multiply with the Jacobian determinant of T.</span>

<span class="sd">            .. math::</span>
<span class="sd">                \tilde{U}(r, \theta) = U(T(r, \theta)) \cdot \det</span>
<span class="sd">                \frac{\partial (x, y)}{\partial (r, \theta)}</span>
<span class="sd">            such that</span>

<span class="sd">            .. math::</span>
<span class="sd">                \int_V \mathop{\mathrm{d}x} \mathop{\mathrm{d}y} U(x,y) =</span>
<span class="sd">                \int_{T^{-1}(V)} \mathop{\mathrm{d}r}\mathop{\mathrm{d}\theta}</span>
<span class="sd">                \tilde{U}(r,\theta)\,.</span>

<span class="sd">            In a 1D to 1D transform, please make sure that the transform function returns the</span>
<span class="sd">            coordinates in a 1-element list, e.g.</span>

<span class="sd">            &gt;&gt;&gt; def T(r):</span>
<span class="sd">            &gt;&gt;&gt;    x = 2*r**2</span>
<span class="sd">            &gt;&gt;&gt;    return [x]</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_coordinates</span><span class="p">(</span><span class="n">newaxes</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">complex_mode</span><span class="o">=</span><span class="n">complex_mode</span><span class="p">,</span>
                                     <span class="n">preserve_integral</span><span class="o">=</span><span class="n">preserve_integral</span><span class="p">,</span>
                                     <span class="n">jacobian_func</span><span class="o">=</span><span class="n">jacobian_func</span><span class="p">,</span>
                                     <span class="n">jacobian_determinant_func</span><span class="o">=</span><span class="n">jacobian_determinant_func</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Field.autoreduce"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.autoreduce">[docs]</a>    <span class="k">def</span> <span class="nf">autoreduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">4000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reduces the Grid to a maximum length of maxlen per dimension</span>
<span class="sd">        by just executing half_resolution as often as necessary.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># half_resolution will take care for the copy</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">maxlen</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">half_resolution</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.cutout"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.cutout">[docs]</a>    <span class="k">def</span> <span class="nf">cutout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newextent</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        only keeps that part of the data, that belongs to newextent.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent_to_slices</span><span class="p">(</span><span class="n">newextent</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span></div>

<div class="viewcode-block" id="Field.autocutout"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.autocutout">[docs]</a>    <span class="k">def</span> <span class="nf">autocutout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fractions</span><span class="o">=</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.002</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Automatically cuts out the main feature of the field by removing border regions</span>
<span class="sd">        that only contain small numbers.</span>

<span class="sd">        This is done axis by axis. For each axis, the mean across all other axes is taken.</span>
<span class="sd">        The maximum `max` of the remaining 1d-`array` is taken and searched for the outermost</span>
<span class="sd">        boundaries a, d such that all values out of array[a:d] are smaller then fractions[0]*max.</span>
<span class="sd">        A second set of boundaries b, c is searched such that all values out of array[b:c] are</span>
<span class="sd">        smaller then fractions[1]*max.</span>
<span class="sd">        Because fractions[1] should be larger than fractions[0], array[b:c] should be contained</span>
<span class="sd">        completely in array[a:d].</span>

<span class="sd">        A padding length x is chosen such that array[b-x:c+x] is entirely within array[a:d].</span>

<span class="sd">        Then the corresponding axis of the field is sliced to [b-x:c+x] and multiplied with a</span>
<span class="sd">        tukey-window such that the region [b:c] is left untouched and the field in the padding</span>
<span class="sd">        region smoothly vanishes on the outer border.</span>

<span class="sd">        This process is repeated for all axes in `axes` or for all axes if `axes` is None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This should be applied only once to each axis&quot;</span><span class="p">)</span>

        <span class="c1"># collect the slices which we will apply to field</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">field</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="c1"># collect the sparse window functions which we will all apply in the end using numexpr</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">field_mean</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">otheraxis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">otheraxis</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">:</span>
                    <span class="n">field_mean</span> <span class="o">=</span> <span class="n">field_mean</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">otheraxis</span><span class="p">)</span>

            <span class="n">k</span> <span class="o">=</span> <span class="n">field_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># outer bounds for lower threshold</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">max_frac_bounds</span><span class="p">(</span><span class="n">field_mean</span><span class="p">,</span> <span class="n">fractions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># inner bounds for higher threshold</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">max_frac_bounds</span><span class="p">(</span><span class="n">field_mean</span><span class="p">,</span> <span class="n">fractions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Above should result in a&lt;=b&lt;=c&lt;=d</span>
            <span class="k">assert</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">d</span>

            <span class="c1"># Length of inner region which will be passed through unchanged</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">c</span><span class="o">-</span><span class="n">b</span>

            <span class="c1"># length of remaining region befor/after inner region</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

            <span class="c1"># final indices of slice</span>
            <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">b</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">x</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

            <span class="c1"># new length of the axis</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">f</span><span class="o">-</span><span class="n">e</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">field</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">windows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tukey</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">ll</span><span class="o">/</span><span class="n">m</span><span class="p">),</span> <span class="n">shape</span><span class="p">))</span>

        <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="s2">&quot;abcdefg&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">varnames</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">local_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">w</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varnames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">windows</span><span class="p">)}</span>
        <span class="n">local_dict</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>

        <span class="k">return</span> <span class="n">field</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">local_dict</span><span class="o">=</span><span class="n">local_dict</span><span class="p">,</span> <span class="n">global_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span></div>

<div class="viewcode-block" id="Field.squeeze"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.squeeze">[docs]</a>    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        removes axes that have length 1, reducing self.dimensions.</span>

<span class="sd">        Note, that axis with length 0 will not be removed! `numpy.squeeze` also does not</span>
<span class="sd">        remove length=0 directions.</span>

<span class="sd">        axis: None or int or tuple of ints, optional</span>
<span class="sd">          Selects a subset of the single-dimensional entries in the shape. If an axis is selected</span>
<span class="sd">          with shape entry greater than one, an error is raised.</span>

<span class="sd">        Same as `numpy.squeeze`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">squeezed_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">squeezed_axes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">squeezed_axes</span><span class="p">:</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.atleast_nd"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.atleast_nd">[docs]</a>    <span class="k">def</span> <span class="nf">atleast_nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Make sure the field has at least &#39;n&#39; dimensions</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">additional_dims</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="n">transform_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_state</span><span class="p">()</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">additional_dims</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Axis</span><span class="p">(</span><span class="n">grid_node</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])))</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transform_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.transpose"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        transpose method equivalent to `numpy.ndarray.transpose`. If `axes` is empty,</span>
<span class="sd">        the order of the</span>
<span class="sd">        axes will be reversed. Otherwise axes[i] == j means that the i&#39;th axis of the returned</span>
<span class="sd">        Field will be the j&#39;th axis of the input Field.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid axes argument&#39;</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Field with the order of axes reversed. In 2D this is the usual matrix</span>
<span class="sd">        transpose operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<div class="viewcode-block" id="Field.swapaxes"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Swaps the axes `axis1` and `axis2`, equivalent to `numpy.swapaxes`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis2</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="p">)</span></div>

    <span class="nb">all</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
    <span class="nb">any</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;any&quot;</span><span class="p">)</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">)</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">)</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;prod&quot;</span><span class="p">)</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
    <span class="n">ptp</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;ptp&quot;</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;std&quot;</span><span class="p">)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">_reducing_numpy_method</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Field.clip"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="Field.flip"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.flip">[docs]</a>    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        functionality of `numpy.flip`.</span>

<span class="sd">        `field.flip(0)` returns a `postpic.Field` object with the</span>
<span class="sd">        specified axis flipped. `np.flip(field)` returns only</span>
<span class="sd">        the `numpy.ndarray` and the axis information is lost.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">reversed</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.rot90"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.rot90">[docs]</a>    <span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the field by 90 degrees, `k` times. Rotates the field in the plane given by `axes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># copied most of the code from</span>
        <span class="c1"># https://github.com/numpy/numpy/blob/v1.15.1/numpy/lib/function_base.py#L62-L145</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(axes) must be 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes must be different.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span>
                <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes=</span><span class="si">{}</span><span class="s2"> out of range for array of ndim=</span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="n">k</span> <span class="o">%=</span> <span class="mi">4</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">axes_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                    <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># k == 3</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes_list</span><span class="p">)</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Field.ensure_positive_axes"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.ensure_positive_axes">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_positive_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ensures, that all axis are going from smaller to greater numbers,</span>
<span class="sd">        i.e. none of the axis is reversed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">isreversed</span><span class="p">():</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">_integrate_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Integrate by assuming constant value across each grid cell, even for uneven grids.</span>
<span class="sd">        This effectively assumes cell-oriented data where each data point already represents</span>
<span class="sd">        an average over its cell</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">)))</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="n">box_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">box_sizes</span><span class="p">)</span>
            <span class="n">box_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">box_sizes</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">*</span> <span class="n">box_sizes</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_integrate_scipy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_integrate_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Integrate by assuming constant value across each grid cell, even for uneven grids.</span>
<span class="sd">        This effectively assumes cell-oriented data where each data point already represents</span>
<span class="sd">        an average over its cell.</span>

<span class="sd">        Note: This is effectively equivalent to _integrate_constant, but should be a lot faster</span>
<span class="sd">        on larger arrays. However for the time being, _integrate_constant is left as is to have a</span>
<span class="sd">        refernce for testing and comparison of speed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># sort the unique set of axes by the number of grid points, in ascending order</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">axes</span><span class="p">:</span>
            <span class="c1"># pops the last value from axes which is the index of the axis with the most points</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1"># get the box sizes along that axis and put them into an array with a shape compatible</span>
            <span class="c1"># with the current matrix</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># perform summation, replace matrix and adapt metadata according to the removal of the</span>
            <span class="c1"># current axis</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;sum((upper-lower) * ret, axis=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

            <span class="c1"># reduce the remaining axis indices by 1, if they refer to an axis with a higher index</span>
            <span class="c1"># than the current axis to account for removal of the current axis</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="Field.integrate"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the definite integral along the given axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method: callable</span>
<span class="sd">            Choose the method to use. Available options:</span>

<span class="sd">            * &#39;constant&#39;</span>
<span class="sd">            * any function with the same signature as scipy.integrate.simps (default).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;fast&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Requested method </span><span class="si">{}</span><span class="s2"> is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_constant</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_fast</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_scipy</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="kn">import</span> <span class="n">parse_version</span>
        <span class="k">if</span> <span class="n">parse_version</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">parse_version</span><span class="p">(</span><span class="s1">&#39;1.9&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">islinear</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This method can only be applied to linear axes.&#39;</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">spacing</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">der_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">parse_version</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">parse_version</span><span class="p">(</span><span class="s1">&#39;1.13&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">islinear</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This method can only be applied to linear axes.&#39;</span><span class="p">)</span>
            <span class="n">der_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this works fine even on non-linear axes</span>
            <span class="n">der_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>

        <span class="n">der_field</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">der_field</span>

    <span class="k">def</span> <span class="nf">_derivative_stagger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">oldax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">oldax</span><span class="o">.</span><span class="n">islinear</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This method can only be applied to linear axes.&#39;</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[:]</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">oldax</span><span class="o">.</span><span class="n">grid_node</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">oldax</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">oldax</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="n">index1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)]</span>
        <span class="n">index1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)]</span>
        <span class="n">index2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">deriv</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index1</span><span class="p">)]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index2</span><span class="p">)])</span><span class="o">/</span><span class="n">oldax</span><span class="o">.</span><span class="n">spacing</span>

        <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">deriv</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

<div class="viewcode-block" id="Field.derivative"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">staggered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the derivative of the field with respect to `axis`.</span>

<span class="sd">        Uses `np.gradient` by default which outputs the second order accurate derivative on the</span>
<span class="sd">        same grid as the input field.</span>

<span class="sd">        If `staggered=True` is passed, the method will instead calculate the second order</span>
<span class="sd">        accurate derivative at the points centered between the input grid points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">staggered</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_stagger</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_transform_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the collective transform state of the given axes.</span>

<span class="sd">        If all mentioned axis i have `self.axes_transform_state[i]==True` return True</span>
<span class="sd">        (All axes live in frequency domain).</span>

<span class="sd">        If all mentioned axis i have self.axes_transform_state[i]==False return False</span>
<span class="sd">        (All axes live in spatial domain)</span>

<span class="sd">        Else return None</span>
<span class="sd">        (Axes have mixed transform_state)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">b</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Field.fft_autopad"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.fft_autopad">[docs]</a>    <span class="k">def</span> <span class="nf">fft_autopad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fft_padsize</span><span class="o">=</span><span class="n">helper</span><span class="o">.</span><span class="n">fftw_padsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically pad the array to a size such that computing its FFT using FFTW will be fast.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fft_padsize: callable</span>
<span class="sd">            The default for keyword argument `fft_padsize` is a callable,</span>
<span class="sd">            that is used to calculate the padded size for a given size.</span>

<span class="sd">            By default, this uses `fft_padsize=helper.fftw_padsize`</span>
<span class="sd">            which finds the next larger &quot;good&quot;</span>
<span class="sd">            grid size according to what the FFTW documentation says.</span>

<span class="sd">            However, the FFTW documentation also says:</span>
<span class="sd">            &quot;(...) Transforms whose sizes are powers of 2 are especially fast.&quot;</span>

<span class="sd">            If you don&#39;t worry about the extra padding, you can pass</span>
<span class="sd">            `fft_padsize=helper.fft_padsize_power2`</span>
<span class="sd">            and this method will pad to the next power of 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>

        <span class="n">pad</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">pad0</span> <span class="o">=</span> <span class="n">fft_padsize</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">-</span> <span class="n">ll</span>
            <span class="n">pad1</span> <span class="o">=</span> <span class="n">pad0</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">pad2</span> <span class="o">=</span> <span class="n">pad0</span> <span class="o">-</span> <span class="n">pad1</span>
            <span class="n">pad</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pad1</span><span class="p">,</span> <span class="n">pad2</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">pad</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_conjugate_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the new grid that will emerge when a FFT would be transformed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If axes is None, transform all axes</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="c1"># If axes is not a tuple, make it a one-tuple</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">spacing</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">}</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="c1"># restore original axes origins</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_axes</span>

<div class="viewcode-block" id="Field.fft"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.fft">[docs]</a>    <span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exponential_signs</span><span class="o">=</span><span class="s1">&#39;spatial&#39;</span><span class="p">,</span> <span class="n">old_behaviour</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs Fourier transform on any number of axes.</span>

<span class="sd">        The argument axis is either an integer indicating the axis to be transformed</span>
<span class="sd">        or a tuple giving the axes that should be transformed. Automatically determines</span>
<span class="sd">        forward/inverse transform. Transform is only applied if all mentioned axes are</span>
<span class="sd">        in the same transform state.</span>
<span class="sd">        If an axis is transformed twice, the origin of the axis is restored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        exponential_signs: string</span>
<span class="sd">            configures the sign convention of the exponential.</span>

<span class="sd">            * exponential_signs == &#39;spatial&#39;:  fft using exp(-ikx), ifft using exp(ikx)</span>
<span class="sd">            * exponential_signs == &#39;temporal&#39;:  fft using exp(iwt), ifft using exp(-iwt)</span>

<span class="sd">        old_behaviour: boolean</span>
<span class="sd">            Do not remove the linear phase present in the fft of data that lie on a grid</span>
<span class="sd">            that does not start at 0. Default is False.</span>

<span class="sd">        **kwargs:</span>
<span class="sd">            keyword-arguments are passed to the underlying fft implementation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># If axes is None, transform all axes</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="c1"># If axes is not a tuple, make it a one-tuple</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">exponential_signs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">,</span> <span class="s1">&#39;temporal&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Argument exponential_signs has an invalid value.&#39;</span><span class="p">)</span>

        <span class="c1"># List axes uniquely and in ascending order</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">islinear</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FFT only allowed for linear grids&quot;</span><span class="p">)</span>

        <span class="c1"># Get the collective transform state of the axes</span>
        <span class="n">transform_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_state</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FFT only allowed if all mentioned axes are in same transform state&quot;</span><span class="p">)</span>

        <span class="c1"># calculates the output axes, factoring in the &quot;transformed_axes_origins&quot;</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conjugate_grid</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Record current axes origins of transformed axes</span>
        <span class="n">input_origins</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">}</span>
        <span class="n">negative_input_origins</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">}</span>
        <span class="n">output_origins</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">new_axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">}</span>
        <span class="n">phi0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">input_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">output_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_behaviour</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transform_state</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">negative_input_origins</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_origins</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">}</span>

        <span class="c1"># Grid spacing</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">spacing</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">}</span>

        <span class="c1"># Unit volume of transform</span>
        <span class="n">dV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># Number of grid cells of transform</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">])</span>

        <span class="c1"># Total volume of transform</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">dV</span><span class="o">*</span><span class="n">N</span>

        <span class="c1"># Total volume of conjugate space</span>
        <span class="c1"># print(&#39;dx&#39;, dx, &#39;dV&#39;, dV, &#39;N&#39;, N, &#39;V&#39;, V)</span>
        <span class="n">Vk</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span><span class="o">/</span><span class="n">dV</span>

        <span class="c1"># normalization factor ensuring Parseval&#39;s Theorem</span>
        <span class="n">fftnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">V</span><span class="o">/</span><span class="n">Vk</span><span class="p">)</span>

        <span class="n">my_fft_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)</span>

        <span class="c1"># Workaround for missing `fft` argument `norm=&#39;ortho&#39;`</span>
        <span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="kn">import</span> <span class="n">parse_version</span>
        <span class="k">if</span> <span class="n">parse_version</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">parse_version</span><span class="p">(</span><span class="s1">&#39;1.10&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">my_fft_args</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">transform_state</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">fftnorm</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform_state</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">fftnorm</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># make a copy with complex type</span>
        <span class="c1"># copy is made explicitly once, so that all further operations (except fft itself,</span>
        <span class="c1"># see below) can be done in place</span>
        <span class="c1"># this is faster than `ndarray.astype()`</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;self + 0j&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exponential_signs</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
            <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;conj(ret)&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

        <span class="c1"># apply phase to shift grid in output domain according to the new_axes</span>
        <span class="c1"># old code: ret = ret._apply_linear_phase(output_origins)</span>
        <span class="n">exp_ikdx_expr</span><span class="p">,</span> <span class="n">expr_dict</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">_linear_phase</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">output_origins</span><span class="p">)</span>
        <span class="n">expr_dict</span><span class="p">[</span><span class="s1">&#39;ret&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;ret * (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exp_ikdx_expr</span><span class="p">),</span>
                    <span class="n">local_dict</span><span class="o">=</span><span class="n">expr_dict</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

        <span class="c1"># Transforming...</span>
        <span class="n">fftfun</span> <span class="o">=</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">}[</span><span class="n">transform_state</span><span class="p">]</span>
        <span class="c1"># numpys fft does not offer an in-place fft</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">fftfun</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">my_fft_args</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transform_state</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">newax</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="s1">&#39;w&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span> <span class="k">else</span> <span class="s1">&#39;k&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                             <span class="s1">&#39;1/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                             <span class="n">grid</span><span class="o">=</span><span class="n">new_axes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newax</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="s1">&#39;t&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;1/&#39;</span><span class="p">),</span>
                             <span class="n">grid</span><span class="o">=</span><span class="n">new_axes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">ret</span><span class="o">.</span><span class="n">setaxisobj</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newax</span><span class="p">)</span>

            <span class="c1"># update transform state and record axes origins</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">transform_state</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># remove phase that stems from the input grid not starting at 0</span>
        <span class="c1"># also removes global phase shift between both domains also to to grid origins not 0</span>
        <span class="c1"># also applies fftnorm</span>
        <span class="c1"># old code: ret = ret._apply_linear_phase(negative_input_origins, phi0=phi0)</span>
        <span class="n">exp_ikdx_expr</span><span class="p">,</span> <span class="n">expr_dict</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">_linear_phase</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">negative_input_origins</span><span class="p">,</span> <span class="n">phi0</span><span class="o">=</span><span class="n">phi0</span><span class="p">)</span>
        <span class="n">expr_dict</span><span class="p">[</span><span class="s1">&#39;ret&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="n">expr_dict</span><span class="p">[</span><span class="s1">&#39;fftnorm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fftnorm</span>
        <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;fftnorm * ret * (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exp_ikdx_expr</span><span class="p">),</span>
                    <span class="n">local_dict</span><span class="o">=</span><span class="n">expr_dict</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exponential_signs</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
            <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;conj(ret)&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.ensure_transform_state"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.ensure_transform_state">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_transform_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform_states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes sure that the field has the given transform_states. `transform_states` may be</span>
<span class="sd">        a single boolean, indicating the same desired transform_state for all axes.</span>
<span class="sd">        It may be a list of the desired transform states for all the axes or a dictionary</span>
<span class="sd">        indicating the desired transform states of specific axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform_states</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform_states</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">transform_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform_states</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="n">transform_states</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">transform_states</span><span class="p">))</span>

        <span class="n">transform_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">axid</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">transform_states</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">[</span><span class="n">axid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">transform_states</span><span class="p">[</span><span class="n">axid</span><span class="p">]:</span>
                <span class="n">transform_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axid</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">transform_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">transform_axes</span><span class="p">))</span></div>

<div class="viewcode-block" id="Field.ensure_spatial_domain"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.ensure_spatial_domain">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_spatial_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_transform_state</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Field.ensure_frequency_domain"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.ensure_frequency_domain">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_frequency_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_transform_state</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_linear_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">phi0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Apply a linear phase as part of translating the grid points.</span>

<span class="sd">        dx should be a mapping from axis number to translation distance</span>
<span class="sd">        All axes must have same transform_state and transformed_axes_origins not None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">transform_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_state</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">transform_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Translation only allowed if all mentioned axes&quot;</span>
                             <span class="s2">&quot;are in same transform state&quot;</span><span class="p">)</span>

        <span class="c1"># exp_ikdx = helper.linear_phase(self, dx)</span>
        <span class="n">exp_ikdx_expr</span><span class="p">,</span> <span class="n">expr_dict</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">_linear_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">phi0</span><span class="o">=</span><span class="n">phi0</span><span class="p">)</span>
        <span class="n">expr_dict</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s1">&#39;self * (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exp_ikdx_expr</span><span class="p">),</span>
                            <span class="n">local_dict</span><span class="o">=</span><span class="n">expr_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_shift_grid_by_fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">skip_fft</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># transform to conjugate space, shift grid origin, transform back</span>
        <span class="c1"># all necessary phases are added by `fft()` method</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_fft</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dx</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_fft</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_shift_grid_by_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">shift_px</span> <span class="o">=</span> <span class="n">shift</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">spnd</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_px</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="n">spnd</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_px</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
            <span class="n">spnd</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">imag</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_px</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">grid_node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">grid_node</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                               <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="Field.shift_grid_by"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.shift_grid_by">[docs]</a>    <span class="k">def</span> <span class="nf">shift_grid_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;fourier&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Translate the Grid by `dx`.</span>
<span class="sd">        This is useful to remove the grid stagger of field components.</span>

<span class="sd">        If all axis will be shifted, `dx` may be a list.</span>
<span class="sd">        Otherwise dx should be a mapping from axis to translation distance.</span>

<span class="sd">        The keyword-argument interpolation indicates the method to be used and</span>
<span class="sd">        may be one of `[&#39;linear&#39;, &#39;fourier&#39;]`.</span>
<span class="sd">        In case of interpolation = &#39;fourier&#39; all axes must have same transform_state.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fourier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shift_grid_by_fourier</span><span class="p">,</span>
                       <span class="n">linear</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shift_grid_by_linear</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">methods</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Requested method </span><span class="si">{}</span><span class="s2"> is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interpolation</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">dx</span><span class="p">))</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="p">{</span><span class="n">helper</span><span class="o">.</span><span class="n">axesidentify</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">methods</span><span class="p">[</span><span class="n">interpolation</span><span class="p">](</span><span class="n">dx</span><span class="p">)</span></div>

<div class="viewcode-block" id="Field.adjust_stagger_to"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.adjust_stagger_to">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_stagger_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">helper</span><span class="o">.</span><span class="n">unstagger_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Field.topolar"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.topolar">[docs]</a>    <span class="nd">@helper</span><span class="o">.</span><span class="n">append_doc_of</span><span class="p">(</span><span class="n">_map_coordinates</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">topolar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angleoffset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the Field to polar coordinates.</span>

<span class="sd">        This is a convenience wrapper for :meth:`map_coordinates` which will let you easily</span>
<span class="sd">        define the desired grid in polar coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extent:</span>
<span class="sd">            should be of the form `extent=(phimin, phimax, rmin, rmax)` or</span>
<span class="sd">            `extent=(phimin, phimax)`</span>
<span class="sd">        shape:</span>
<span class="sd">            should be of the form `shape=(N_phi, N_r)`,</span>
<span class="sd">        angleoffset:</span>
<span class="sd">            can be any real number and will rotate the zero-point of the angular axis.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Fill extent and shape with sensible defaults if nothing was passed</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">r_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">r_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">]</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ptr_r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">))</span>
            <span class="n">ptr_r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">ptr_r</span><span class="p">)</span>
            <span class="n">ptr_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">))</span>
            <span class="n">ptr_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">ptr_t</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptr_t</span><span class="p">,</span> <span class="n">ptr_r</span><span class="p">)</span>

        <span class="c1"># Create the new axes objects</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span>
                     <span class="n">grid</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">theta_offset</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span>
                            <span class="n">grid</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">angleoffset</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">):</span>
            <span class="n">rname</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rname</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">rname</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                 <span class="n">grid</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Perform the transformation</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">([</span><span class="n">theta_offset</span><span class="p">,</span> <span class="n">r</span><span class="p">],</span>
                                   <span class="n">transform</span><span class="o">=</span><span class="n">helper</span><span class="o">.</span><span class="n">polar2linear</span><span class="p">,</span>
                                   <span class="n">jacobian_determinant_func</span><span class="o">=</span><span class="n">helper</span><span class="o">.</span><span class="n">polar2linear_jacdet</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Remove the angleoffset from the theta grid</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">setaxisobj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Field.export"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.export">[docs]</a>    <span class="nd">@helper</span><span class="o">.</span><span class="n">append_doc_of</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">export_field</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Uses `postpic.export_field` to export this field to a file. All ``**kwargs`</span>
<span class="sd">        will be forwarded to this function.</span>
<span class="sd">        Format is recognized by the extension</span>
<span class="sd">        of the filename.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">io</span><span class="o">.</span><span class="n">export_field</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Field.saveto"><a class="viewcode-back" href="../../apidoc/postpic.html#postpic.Field.saveto">[docs]</a>    <span class="k">def</span> <span class="nf">saveto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">compressed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Save a Field object as a file. Use `loadfrom()` to load Field objects.</span>
<span class="sd">        The &#39;.npz&#39; file name extension will be added automatically, if missing.</span>
<span class="sd">        Pass compressed=False to skip deflate compression, if compression takes too long.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npz&#39;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="s1">&#39;.npz&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">compressed</span><span class="o">=</span><span class="n">compressed</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&lt;postpic.Field &quot;</span><span class="si">{:}</span><span class="s1">&quot; </span><span class="si">{:}</span><span class="s1">&gt;&#39;</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

    <span class="k">def</span> <span class="nf">_extent_to_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;size of extent doesnt match self.dimensions * 2&#39;</span><span class="p">)</span>

        <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">extent</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">_extent_to_slice</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ex</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">extent</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_normalize_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">D Field requires a </span><span class="si">{}</span><span class="s2">-tuple of slices as index&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">_normalize_slice</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

    <span class="c1"># Operator overloading</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">old_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_slices</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">retained_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sl</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
                <span class="n">new_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retained_axes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">retained_axes</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_axes</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setaxisobj</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">axes_transform_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">axes_transform_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">retained_axes</span><span class="p">]</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">transformed_axes_origins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">retained_axes</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_slices</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">postpic</a></h1>



<p class="blurb">the open-source partice-in-cell postprocessor.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=skuschel&repo=postpic&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getstarted.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG.html">Changelog of postpic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CONTRIBUTING.html">Contributing to the postpic code base</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">postpic</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, the postpic developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/skuschel/postpic" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>